// =====================================================
// PIC16F877A FINGERPRINT SENSOR SYSTEM
// R307 Fingerprint + Servo + Buzzer + Menu System
// Stable, Non-blocking, Debounced Button Input
// =====================================================

#include <xc.h>
#include <string.h>
#include <stdio.h>

// Configuration Bits
#pragma config FOSC = HS    // 4MHz HS oscillator
#pragma config WDTE = OFF   // Watchdog disabled
#pragma config PWRTE = ON   // Power-up timer on
#pragma config CP = OFF     // Code protection off
#pragma config BOREN = ON   // Brown-out reset on
#pragma config LVP = OFF    // Low voltage programming off
#pragma config CPD = OFF    // Data EEPROM protection off

#define _XTAL_FREQ 4000000

// ============ LCD PINS ============
#define LCD_D0 RB0
#define LCD_D1 RB1
#define LCD_D2 RB2
#define LCD_D3 RB3
#define LCD_D4 RB4
#define LCD_D5 RB5
#define LCD_D6 RB6
#define LCD_D7 RB7
#define LCD_RS RC0
#define LCD_EN RC1

// ============ BUTTON PINS (PORTB) ============
#define BTN_MENU RB6        // Menu enter
#define BTN_UP RB1          // Navigate up
#define BTN_DOWN RB2        // Navigate down
#define BTN_CONFIRM RB3     // Confirm selection
#define BUZZER RB5          // Buzzer
#define SERVO RC2           // Servo control (PWM)

// ============ PASSWORD BUTTONS (PORTA) ============
#define BTN_DIGIT1 RA0      // Digit 1
#define BTN_DIGIT2 RA1      // Digit 2
#define BTN_DIGIT3 RA2      // Digit 3
#define BTN_DIGIT4 RA3      // Digit 4

// ============ R307 UART (RC6=TX, RC7=RX) ============

// ============ STATES ============
#define STATE_IDLE 0
#define STATE_MENU 1
#define STATE_ENROLL 2
#define STATE_DELETE 3
#define STATE_PASSWORD 4
#define STATE_VERIFY 5
#define STATE_UNLOCK 6
#define STATE_CHANGE_PWD 7

// ============ MENU OPTIONS ============
#define MENU_VERIFY 0
#define MENU_ENROLL 1
#define MENU_DELETE 2
#define MENU_PASSWORD 3
#define MENU_CHANGE_PWD 4

// ============ STRUCTURE FOR SYSTEM STATE ============
typedef struct {
    unsigned char current_state;
    unsigned char menu_pos;
    unsigned char enrolled_count;
    unsigned char password[4];
    unsigned char pwd_input[4];
    unsigned char pwd_idx;
    unsigned char finger_id;
} SYSTEM_STATE;

// ============ DEBOUNCE STRUCTURE ============
typedef struct {
    unsigned char btn_menu_cnt;
    unsigned char btn_up_cnt;
    unsigned char btn_down_cnt;
    unsigned char btn_confirm_cnt;
    unsigned char btn_d1_cnt;
    unsigned char btn_d2_cnt;
    unsigned char btn_d3_cnt;
    unsigned char btn_d4_cnt;
    unsigned char btn_menu_prev;
    unsigned char btn_up_prev;
    unsigned char btn_down_prev;
    unsigned char btn_confirm_prev;
    unsigned char btn_d1_prev;
    unsigned char btn_d2_prev;
    unsigned char btn_d3_prev;
    unsigned char btn_d4_prev;
} DEBOUNCE_STATE;

// ============ GLOBAL VARIABLES ============
SYSTEM_STATE sys_state;
DEBOUNCE_STATE debounce;
unsigned int timer_counter = 0;
unsigned char uart_rx_data;
unsigned char uart_flag = 0;

// ============ FUNCTION PROTOTYPES ============
void init_system(void);
void init_uart(void);
void init_pwm(void);
void init_timer(void);
void lcd_init(void);
void lcd_cmd(unsigned char);
void lcd_data(unsigned char);
void lcd_print(unsigned char row, unsigned char col, const char *text);
void lcd_clear(void);
void delay_ms(unsigned int);
void buzzer_beep(unsigned char);
void servo_move(unsigned char);
void button_scan(void);
void handle_menu(void);
void display_menu(void);
void display_idle(void);
void uart_send(unsigned char);
unsigned char uart_recv(void);
void uart_send_cmd(unsigned char *, unsigned char);
void r307_enroll(unsigned char);
void r307_delete(unsigned char);
void r307_verify(void);
void password_input(void);
void change_password(void);
void state_machine(void);

// ============ INITIALIZATION ============
void init_system(void) {
    // Configure ports
    TRISA = 0x0F;   // RA0-RA3 inputs (password buttons)
    TRISB = 0x4E;   // RB1,2,3,6 inputs | RB0,4,5,7 outputs
    TRISC = 0x80;   // RC7 input (UART RX), others outputs
    
    PORTA = 0;
    PORTB = 0;
    PORTC = 0;
    
    // Initialize debounce counters
    memset(&debounce, 0, sizeof(DEBOUNCE_STATE));
    
    // Initialize system state
    sys_state.current_state = STATE_IDLE;
    sys_state.menu_pos = 0;
    sys_state.enrolled_count = 0;
    sys_state.pwd_idx = 0;
    
    // Default password: 1234
    sys_state.password[0] = 1;
    sys_state.password[1] = 2;
    sys_state.password[2] = 3;
    sys_state.password[3] = 4;
    
    init_uart();
    init_pwm();
    init_timer();
    lcd_init();
    
    display_idle();
}

void init_uart(void) {
    SPBRG = 25;     // 9600 baud @ 4MHz
    TXSTA = 0x24;   // TX enabled, BRGH=1
    RCSTA = 0x90;   // RX enabled
    PIE1bits.RCIE = 1;  // RX interrupt enabled
    GIE = 1;        // Global interrupt enabled
}

void init_pwm(void) {
    PR2 = 199;      // PWM frequency ~1kHz
    CCP2CON = 0x0C; // PWM mode
    T2CON = 0x04;   // Timer2 on, prescale 1:1
    CCPR2L = 10;    // Initial servo position (0 degrees)
}

void init_timer(void) {
    TMR0 = 0;
    OPTION_REG = 0x87;  // Prescale 1:128, 10ms tick
    INTCONbits.T0IE = 1;
    INTCONbits.GIE = 1;
}

// ============ INTERRUPT HANDLERS ============
void interrupt ISR(void) {
    if (INTCONbits.T0IF) {
        INTCONbits.T0IF = 0;
        timer_counter++;
        
        // 10ms tick counter for state machine timing
        if (timer_counter >= 10) {
            timer_counter = 0;
        }
    }
    
    if (PIR1bits.RCIF) {
        uart_rx_data = RCREG;
        uart_flag = 1;
    }
}

// ============ LCD FUNCTIONS ============
void lcd_init(void) {
    delay_ms(15);
    lcd_cmd(0x38);  // 8-bit, 2 lines
    delay_ms(5);
    lcd_cmd(0x0C);  // Display ON, cursor OFF
    delay_ms(5);
    lcd_cmd(0x01);  // Clear display
    delay_ms(2);
    lcd_cmd(0x06);  // Entry mode
    delay_ms(2);
}

void lcd_cmd(unsigned char cmd) {
    PORTB = cmd;
    LCD_RS = 0;
    LCD_EN = 1;
    __delay_us(2);
    LCD_EN = 0;
    delay_ms(2);
}

void lcd_data(unsigned char dat) {
    PORTB = dat;
    LCD_RS = 1;
    LCD_EN = 1;
    __delay_us(2);
    LCD_EN = 0;
    delay_ms(2);
}

void lcd_print(unsigned char row, unsigned char col, const char *text) {
    unsigned char addr = (row == 0) ? 0x00 : 0x40;
    addr += col;
    lcd_cmd(0x80 | addr);
    delay_ms(1);
    
    while (*text) {
        lcd_data(*text++);
        delay_ms(1);
    }
}

void lcd_clear(void) {
    lcd_cmd(0x01);
    delay_ms(2);
}

// ============ UTILITY FUNCTIONS ============
void delay_ms(unsigned int ms) {
    unsigned int i, j;
    for (i = 0; i < ms; i++)
        for (j = 0; j < 123; j++);
}

void buzzer_beep(unsigned char times) {
    unsigned char i;
    for (i = 0; i < times; i++) {
        BUZZER = 1;
        delay_ms(100);
        BUZZER = 0;
        delay_ms(100);
    }
}

void servo_move(unsigned char angle) {
    // angle: 0-180 degrees
    // PWM: 50-250 corresponds to 0-180 degrees
    unsigned char pwm_val = 50 + (angle * 200 / 180);
    CCPR2L = pwm_val;
}

// ============ BUTTON DEBOUNCE AND SCANNING ============
void button_scan(void) {
    // Debounce: 20ms stable time (2 * 10ms)
    
    // Menu button
    if (BTN_MENU == debounce.btn_menu_prev) {
        if (debounce.btn_menu_cnt < 2) debounce.btn_menu_cnt++;
    } else {
        debounce.btn_menu_cnt = 0;
    }
    debounce.btn_menu_prev = BTN_MENU;
    
    // Up button
    if (BTN_UP == debounce.btn_up_prev) {
        if (debounce.btn_up_cnt < 2) debounce.btn_up_cnt++;
    } else {
        debounce.btn_up_cnt = 0;
    }
    debounce.btn_up_prev = BTN_UP;
    
    // Down button
    if (BTN_DOWN == debounce.btn_down_prev) {
        if (debounce.btn_down_cnt < 2) debounce.btn_down_cnt++;
    } else {
        debounce.btn_down_cnt = 0;
    }
    debounce.btn_down_prev = BTN_DOWN;
    
    // Confirm button
    if (BTN_CONFIRM == debounce.btn_confirm_prev) {
        if (debounce.btn_confirm_cnt < 2) debounce.btn_confirm_cnt++;
    } else {
        debounce.btn_confirm_cnt = 0;
    }
    debounce.btn_confirm_prev = BTN_CONFIRM;
    
    // Password digit buttons
    if (BTN_DIGIT1 == debounce.btn_d1_prev) {
        if (debounce.btn_d1_cnt < 2) debounce.btn_d1_cnt++;
    } else {
        debounce.btn_d1_cnt = 0;
    }
    debounce.btn_d1_prev = BTN_DIGIT1;
    
    if (BTN_DIGIT2 == debounce.btn_d2_prev) {
        if (debounce.btn_d2_cnt < 2) debounce.btn_d2_cnt++;
    } else {
        debounce.btn_d2_cnt = 0;
    }
    debounce.btn_d2_prev = BTN_DIGIT2;
    
    if (BTN_DIGIT3 == debounce.btn_d3_prev) {
        if (debounce.btn_d3_cnt < 2) debounce.btn_d3_cnt++;
    } else {
        debounce.btn_d3_cnt = 0;
    }
    debounce.btn_d3_prev = BTN_DIGIT3;
    
    if (BTN_DIGIT4 == debounce.btn_d4_prev) {
        if (debounce.btn_d4_cnt < 2) debounce.btn_d4_cnt++;
    } else {
        debounce.btn_d4_cnt = 0;
    }
    debounce.btn_d4_prev = BTN_DIGIT4;
}

unsigned char btn_menu_pressed(void) {
    if (debounce.btn_menu_cnt >= 2 && !BTN_MENU) {
        debounce.btn_menu_cnt = 0;
        return 1;
    }
    return 0;
}

unsigned char btn_up_pressed(void) {
    if (debounce.btn_up_cnt >= 2 && !BTN_UP) {
        debounce.btn_up_cnt = 0;
        return 1;
    }
    return 0;
}

unsigned char btn_down_pressed(void) {
    if (debounce.btn_down_cnt >= 2 && !BTN_DOWN) {
        debounce.btn_down_cnt = 0;
        return 1;
    }
    return 0;
}

unsigned char btn_confirm_pressed(void) {
    if (debounce.btn_confirm_cnt >= 2 && !BTN_CONFIRM) {
        debounce.btn_confirm_cnt = 0;
        return 1;
    }
    return 0;
}

unsigned char btn_digit_pressed(unsigned char *digit) {
    if (debounce.btn_d1_cnt >= 2 && !BTN_DIGIT1) {
        debounce.btn_d1_cnt = 0;
        *digit = 1;
        return 1;
    }
    if (debounce.btn_d2_cnt >= 2 && !BTN_DIGIT2) {
        debounce.btn_d2_cnt = 0;
        *digit = 2;
        return 1;
    }
    if (debounce.btn_d3_cnt >= 2 && !BTN_DIGIT3) {
        debounce.btn_d3_cnt = 0;
        *digit = 3;
        return 1;
    }
    if (debounce.btn_d4_cnt >= 2 && !BTN_DIGIT4) {
        debounce.btn_d4_cnt = 0;
        *digit = 4;
        return 1;
    }
    return 0;
}

// ============ UART FUNCTIONS ============
void uart_send(unsigned char dat) {
    while (!TXSTAbits.TRMT);
    TXREG = dat;
}

unsigned char uart_recv(void) {
    if (uart_flag) {
        uart_flag = 0;
        return uart_rx_data;
    }
    return 0xFF;
}

void uart_send_cmd(unsigned char *cmd, unsigned char len) {
    unsigned char i;
    for (i = 0; i < len; i++) {
        uart_send(cmd[i]);
        delay_ms(5);
    }
}

// ============ R307 FINGERPRINT FUNCTIONS ============
void r307_enroll(unsigned char id) {
    // Simplified R307 enrollment
    // Full implementation requires R307 protocol handling
    lcd_clear();
    lcd_print(0, 0, "Enroll Finger");
    lcd_print(1, 0, "ID: ");
    
    char id_str[3];
    sprintf(id_str, "%d", id);
    lcd_print(1, 4, id_str);
    
    buzzer_beep(2);
    delay_ms(500);
    
    // Wait for sensor response (non-blocking should be implemented)
    unsigned int timeout = 0;
    while (timeout < 200) {
        if (uart_flag) {
            unsigned char dat = uart_recv();
            if (dat == 0x00) {  // Success code
                buzzer_beep(1);
                sys_state.enrolled_count++;
                return;
            }
        }
        timeout++;
        delay_ms(10);
    }
    
    buzzer_beep(3);  // Error
}

void r307_delete(unsigned char id) {
    lcd_clear();
    lcd_print(0, 0, "Delete Finger");
    lcd_print(1, 0, "ID: ");
    
    char id_str[3];
    sprintf(id_str, "%d", id);
    lcd_print(1, 4, id_str);
    
    buzzer_beep(2);
    delay_ms(500);
    
    if (sys_state.enrolled_count > 0) {
        sys_state.enrolled_count--;
        buzzer_beep(1);
    } else {
        buzzer_beep(3);
    }
}

void r307_verify(void) {
    lcd_clear();
    lcd_print(0, 0, "Place Finger");
    lcd_print(1, 0, "on Sensor");
    
    buzzer_beep(1);
    
    unsigned int timeout = 0;
    while (timeout < 300) {
        if (uart_flag) {
            unsigned char dat = uart_recv();
            if (dat == 0x00) {  // Match found
                buzzer_beep(2);
                sys_state.current_state = STATE_UNLOCK;
                servo_move(180);
                delay_ms(3000);
                servo_move(0);
                return;
            }
        }
        timeout++;
        delay_ms(10);
    }
    
    lcd_clear();
    lcd_print(0, 0, "No Match!");
    buzzer_beep(3);
    delay_ms(2000);
    sys_state.current_state = STATE_IDLE;
}

// ============ PASSWORD FUNCTIONS ============
void password_input(void) {
    unsigned char digit;
    
    lcd_clear();
    lcd_print(0, 0, "Enter Password:");
    sys_state.pwd_idx = 0;
    
    while (sys_state.pwd_idx < 4) {
        button_scan();
        
        if (btn_digit_pressed(&digit)) {
            sys_state.pwd_input[sys_state.pwd_idx] = digit;
            lcd_print(1, sys_state.pwd_idx, "*");
            sys_state.pwd_idx++;
            buzzer_beep(1);
            delay_ms(300);
        }
        
        delay_ms(10);
    }
    
    // Verify password
    unsigned char match = 1;
    unsigned char i;
    for (i = 0; i < 4; i++) {
        if (sys_state.pwd_input[i] != sys_state.password[i]) {
            match = 0;
            break;
        }
    }
    
    if (match) {
        lcd_clear();
        lcd_print(0, 0, "Correct!");
        buzzer_beep(2);
        delay_ms(1000);
        
        // Unlock
        servo_move(180);
        delay_ms(3000);
        servo_move(0);
        
        sys_state.current_state = STATE_IDLE;
    } else {
        lcd_clear();
        lcd_print(0, 0, "Wrong Password!");
        buzzer_beep(3);
        delay_ms(2000);
        sys_state.current_state = STATE_IDLE;
    }
}

void change_password(void) {
    lcd_clear();
    lcd_print(0, 0, "New Password:");
    sys_state.pwd_idx = 0;
    unsigned char digit;
    
    while (sys_state.pwd_idx < 4) {
        button_scan();
        
        if (btn_digit_pressed(&digit)) {
            sys_state.password[sys_state.pwd_idx] = digit;
            lcd_print(1, sys_state.pwd_idx, "*");
            sys_state.pwd_idx++;
            buzzer_beep(1);
            delay_ms(300);
        }
        
        delay_ms(10);
    }
    
    lcd_clear();
    lcd_print(0, 0, "Password Changed");
    buzzer_beep(2);
    delay_ms(2000);
    sys_state.current_state = STATE_IDLE;
}

// ============ DISPLAY FUNCTIONS ============
void display_idle(void) {
    lcd_clear();
    lcd_print(0, 0, "BIGGR FISH IN");
    lcd_print(1, 0, "POND");
}

void display_menu(void) {
    lcd_clear();
    
    const char *menu_items[] = {"Verify", "Enroll", "Delete", "Password", "Change PWD"};
    
    lcd_print(0, 0, "-> ");
    lcd_print(0, 3, menu_items[sys_state.menu_pos]);
    
    if (sys_state.menu_pos > 0) {
        lcd_print(1, 3, menu_items[sys_state.menu_pos - 1]);
    } else {
        lcd_print(1, 3, menu_items[4]);
    }
}

// ============ MENU HANDLING ============
void handle_menu(void) {
    if (btn_up_pressed()) {
        sys_state.menu_pos = (sys_state.menu_pos == 0) ? 4 : sys_state.menu_pos - 1;
        buzzer_beep(1);
        display_menu();
    }
    
    if (btn_down_pressed()) {
        sys_state.menu_pos = (sys_state.menu_pos == 4) ? 0 : sys_state.menu_pos + 1;
        buzzer_beep(1);
        display_menu();
    }
    
    if (btn_confirm_pressed()) {
        buzzer_beep(1);
        
        switch (sys_state.menu_pos) {
            case MENU_VERIFY:
                sys_state.current_state = STATE_VERIFY;
                r307_verify();
                break;
            case MENU_ENROLL:
                sys_state.current_state = STATE_ENROLL;
                r307_enroll(sys_state.enrolled_count + 1);
                sys_state.current_state = STATE_IDLE;
                break;
            case MENU_DELETE:
                sys_state.current_state = STATE_DELETE;
                r307_delete(sys_state.enrolled_count);
                sys_state.current_state = STATE_IDLE;
                break;
            case MENU_PASSWORD:
                sys_state.current_state = STATE_PASSWORD;
                password_input();
                break;
            case MENU_CHANGE_PWD:
                sys_state.current_state = STATE_CHANGE_PWD;
                change_password();
                break;
        }
    }
}

// ============ STATE MACHINE ============
void state_machine(void) {
    button_scan();
    
    switch (sys_state.current_state) {
        case STATE_IDLE:
            if (btn_menu_pressed()) {
                sys_state.current_state = STATE_MENU;
                sys_state.menu_pos = 0;
                display_menu();
                buzzer_beep(1);
            }
            break;
        
        case STATE_MENU:
            if (btn_menu_pressed()) {
                sys_state.current_state = STATE_IDLE;
                display_idle();
                buzzer_beep(1);
            } else {
                handle_menu();
            }
            break;
    }
}

// ============ MAIN PROGRAM ============
void main(void) {
    init_system();
    
    while (1) {
        state_machine();
        delay_ms(20);  // 20ms main loop
    }
}
