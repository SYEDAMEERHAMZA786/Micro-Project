// ============================================================================
// FINGERPRINT SECURITY SYSTEM - PIC16F877A + R307 + SG90
// Complete working code with FIXED servo timing - No variable delays
// ============================================================================

#define _XTAL_FREQ 4000000

#include <xc.h>
#include <stdint.h>
#include <string.h>

#pragma config FOSC = XT
#pragma config WDTE = OFF
#pragma config PWRTE = ON
#pragma config BOREN = ON
#pragma config LVP = OFF
#pragma config CPD = OFF
#pragma config WRT = OFF
#pragma config CP = OFF

// Pin Definitions
#define LCD_RS RC0
#define LCD_EN RC1
#define LCD_DATA PORTD
#define BTN_MENU PORTBbits.RB6
#define BTN_UP PORTBbits.RB2
#define BTN_DOWN PORTBbits.RB1
#define BTN_CONFIRM PORTBbits.RB3
#define BUZZER PORTBbits.RB5
#define PASS_BTN1 PORTAbits.RA3
#define PASS_BTN2 PORTAbits.RA2
#define PASS_BTN3 PORTAbits.RA1
#define PASS_BTN4 PORTAbits.RA0
#define SERVO_PIN RC2

// Constants
#define DEBOUNCE_TIME 50
#define PASSWORD_LENGTH 4
#define MENU_ITEMS 5
#define R307_GENIMAGE 0x01
#define R307_IMAGE2TZ 0x02
#define R307_SEARCH 0x04
#define R307_REGMODEL 0x05
#define R307_STORE 0x06
#define R307_DELETE 0x0C
#define R307_TEMPLATECOUNT 0x1D

// Global Variables
uint8_t current_password[PASSWORD_LENGTH] = {1, 2, 3, 4};
uint8_t menu_index = 0;
uint8_t system_state = 0;
uint8_t fingerprint_count = 0;

const char* menu_items[MENU_ITEMS] = {
    "1.Verify Finger",
    "2.Add Finger   ",
    "3.Delete Finger",
    "4.Password Open",
    "5.Change Pass  "
};

// Function Prototypes
void LCD_Command(uint8_t cmd);
void LCD_Char(char data);
void LCD_Init(void);
void LCD_Clear(void);
void LCD_SetCursor(uint8_t row, uint8_t col);
void LCD_String(const char* str);
void LCD_Number(uint16_t num);
void Buzzer_Beep(uint8_t count);
void Buzzer_Success(void);
void Buzzer_Error(void);
void Servo_Init(void);
void custom_delay_us(uint16_t us);
void servo_pulse_angle(uint8_t angle);
void Servo_Set_Angle(uint8_t angle);
void Servo_Sweep(uint8_t start_angle, uint8_t end_angle, uint16_t duration_ms);
void Servo_Open(void);
uint8_t Button_Read_Menu(void);
uint8_t Button_Read_Up(void);
uint8_t Button_Read_Down(void);
uint8_t Button_Read_Confirm(void);
uint8_t Button_Read_Pass1(void);
uint8_t Button_Read_Pass2(void);
uint8_t Button_Read_Pass3(void);
uint8_t Button_Read_Pass4(void);
void UART_Init(void);
void UART_Write(uint8_t data);
uint8_t UART_Read(void);
uint8_t UART_Available(void);
void UART_Flush(void);
uint16_t R307_CalculateChecksum(uint8_t* packet, uint8_t len);
void R307_SendPacket(uint8_t cmd, uint8_t* params, uint8_t param_len);
uint8_t R307_ReceivePacket(uint8_t* response, uint16_t timeout);
uint8_t R307_GetImage(void);
uint8_t R307_Image2Tz(uint8_t slot);
uint8_t R307_CreateModel(void);
uint8_t R307_StoreModel(uint8_t slot, uint16_t id);
uint8_t R307_Search(uint8_t slot, uint16_t* id, uint16_t* score);
uint8_t R307_DeleteModel(uint16_t id, uint16_t count);
uint8_t R307_GetTemplateCount(uint16_t* count);
void Display_Idle(void);
void Display_Menu(void);
uint8_t Get_Password_Input(void);
void Verify_Fingerprint(void);
void Add_Fingerprint(void);
void Delete_Fingerprint(void);
void Password_Open(void);
void Change_Password(void);

// ============================================================================
// LCD FUNCTIONS
// ============================================================================
void LCD_Command(uint8_t cmd) {
    LCD_RS = 0;
    LCD_DATA = cmd;
    LCD_EN = 1;
    __delay_us(50);
    LCD_EN = 0;
    __delay_ms(2);
}

void LCD_Char(char data) {
    LCD_RS = 1;
    LCD_DATA = data;
    LCD_EN = 1;
    __delay_us(50);
    LCD_EN = 0;
    __delay_us(100);
}

void LCD_Init(void) {
    __delay_ms(20);
    LCD_Command(0x38);
    LCD_Command(0x0C);
    LCD_Command(0x06);
    LCD_Command(0x01);
    __delay_ms(2);
}

void LCD_Clear(void) {
    LCD_Command(0x01);
    __delay_ms(2);
}

void LCD_SetCursor(uint8_t row, uint8_t col) {
    uint8_t pos = (row == 0) ? 0x80 + col : 0xC0 + col;
    LCD_Command(pos);
}

void LCD_String(const char* str) {
    while(*str) {
        LCD_Char(*str++);
    }
}

void LCD_Number(uint16_t num) {
    char buffer[6];
    uint8_t i = 0;
    
    if(num == 0) {
        LCD_Char('0');
        return;
    }
    
    while(num > 0) {
        buffer[i++] = (num % 10) + '0';
        num /= 10;
    }
    
    while(i > 0) {
        LCD_Char(buffer[--i]);
    }
}

// ============================================================================
// BUZZER FUNCTIONS
// ============================================================================
void Buzzer_Beep(uint8_t count) {
    uint8_t i;
    for(i = 0; i < count; i++) {
        BUZZER = 1;
        __delay_ms(50);
        BUZZER = 0;
        __delay_ms(50);
    }
}

void Buzzer_Success(void) {
    BUZZER = 1;
    __delay_ms(150);
    BUZZER = 0;
}

void Buzzer_Error(void) {
    uint8_t i;
    for(i = 0; i < 3; i++) {
        BUZZER = 1;
        __delay_ms(40);
        BUZZER = 0;
        __delay_ms(40);
    }
}

// ============================================================================
// SERVO FUNCTIONS - FIXED FOR XC8 COMPILER
// ============================================================================
void Servo_Init(void) {
    TRISCbits.TRISC2 = 0;
    SERVO_PIN = 0;
}

// Custom microsecond delay using NOP instructions
// At 4MHz: 1 instruction cycle = 1us
void custom_delay_us(uint16_t us) {
    while(us--) {
        NOP();  // 1us at 4MHz
    }
}

// Generate pulse for specific angle - using only constant delays
void servo_pulse_angle(uint8_t angle) {
    uint16_t pulse_width;
    uint16_t off_time;
    uint16_t i;
    
    // Limit angle
    if(angle > 180) angle = 180;
    
    // Calculate pulse width (1000-2000us)
    pulse_width = 1000 + ((uint16_t)angle * 1000 / 180);
    off_time = 20000 - pulse_width;
    
    // Generate HIGH pulse
    SERVO_PIN = 1;
    
    // Pulse width delay using loop
    for(i = 0; i < pulse_width; i++) {
        NOP();
    }
    
    SERVO_PIN = 0;
    
    // Off time delay
    for(i = 0; i < off_time; i++) {
        NOP();
    }
}

// Set servo to specific angle - send 20 pulses
void Servo_Set_Angle(uint8_t angle) {
    uint8_t i;
    for(i = 0; i < 20; i++) {
        servo_pulse_angle(angle);
    }
}

// Sweep servo between angles
void Servo_Sweep(uint8_t start_angle, uint8_t end_angle, uint16_t duration_ms) {
    uint16_t steps;
    uint16_t i;
    int16_t angle_diff;
    uint8_t current_angle;
    
    // Calculate steps (20ms per pulse)
    steps = duration_ms / 20;
    if(steps < 1) steps = 1;
    
    angle_diff = (int16_t)end_angle - (int16_t)start_angle;
    
    // Sweep
    for(i = 0; i <= steps; i++) {
        current_angle = start_angle + ((int16_t)angle_diff * i / steps);
        servo_pulse_angle(current_angle);
    }
    
    // Hold final position
    for(i = 0; i < 5; i++) {
        servo_pulse_angle(end_angle);
    }
}

// Door open sequence
void Servo_Open(void) {
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Opening...");
    
    // Open door
    Servo_Sweep(0, 180, 800);
    
    LCD_SetCursor(1, 0);
    LCD_String("Access Granted!");
    
    // Hold open
    __delay_ms(2000);
    
    LCD_SetCursor(1, 0);
    LCD_String("Closing...    ");
    
    // Close door
    Servo_Sweep(180, 0, 800);
    
    // Lock position
    Servo_Set_Angle(0);
    
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Door Closed!");
    __delay_ms(500);
}

// ============================================================================
// BUTTON FUNCTIONS
// ============================================================================
uint8_t Button_Read_Menu(void) {
    if(BTN_MENU == 1) {
        __delay_ms(DEBOUNCE_TIME);
        if(BTN_MENU == 1) {
            while(BTN_MENU == 1);
            __delay_ms(DEBOUNCE_TIME);
            return 1;
        }
    }
    return 0;
}

uint8_t Button_Read_Up(void) {
    if(BTN_UP == 1) {
        __delay_ms(DEBOUNCE_TIME);
        if(BTN_UP == 1) {
            while(BTN_UP == 1);
            __delay_ms(DEBOUNCE_TIME);
            return 1;
        }
    }
    return 0;
}

uint8_t Button_Read_Down(void) {
    if(BTN_DOWN == 1) {
        __delay_ms(DEBOUNCE_TIME);
        if(BTN_DOWN == 1) {
            while(BTN_DOWN == 1);
            __delay_ms(DEBOUNCE_TIME);
            return 1;
        }
    }
    return 0;
}

uint8_t Button_Read_Confirm(void) {
    if(BTN_CONFIRM == 1) {
        __delay_ms(DEBOUNCE_TIME);
        if(BTN_CONFIRM == 1) {
            while(BTN_CONFIRM == 1);
            __delay_ms(DEBOUNCE_TIME);
            return 1;
        }
    }
    return 0;
}

uint8_t Button_Read_Pass1(void) {
    if(PASS_BTN1 == 1) {
        __delay_ms(DEBOUNCE_TIME);
        if(PASS_BTN1 == 1) {
            while(PASS_BTN1 == 1);
            __delay_ms(DEBOUNCE_TIME);
            return 1;
        }
    }
    return 0;
}

uint8_t Button_Read_Pass2(void) {
    if(PASS_BTN2 == 1) {
        __delay_ms(DEBOUNCE_TIME);
        if(PASS_BTN2 == 1) {
            while(PASS_BTN2 == 1);
            __delay_ms(DEBOUNCE_TIME);
            return 1;
        }
    }
    return 0;
}

uint8_t Button_Read_Pass3(void) {
    if(PASS_BTN3 == 1) {
        __delay_ms(DEBOUNCE_TIME);
        if(PASS_BTN3 == 1) {
            while(PASS_BTN3 == 1);
            __delay_ms(DEBOUNCE_TIME);
            return 1;
        }
    }
    return 0;
}

uint8_t Button_Read_Pass4(void) {
    if(PASS_BTN4 == 1) {
        __delay_ms(DEBOUNCE_TIME);
        if(PASS_BTN4 == 1) {
            while(PASS_BTN4 == 1);
            __delay_ms(DEBOUNCE_TIME);
            return 1;
        }
    }
    return 0;
}

// ============================================================================
// UART FUNCTIONS
// ============================================================================
void UART_Init(void) {
    TRISCbits.TRISC6 = 0;
    TRISCbits.TRISC7 = 1;
    SPBRG = 25;
    TXSTA = 0x24;
    RCSTA = 0x90;
}

void UART_Write(uint8_t data) {
    while(!TXIF);
    TXREG = data;
}

uint8_t UART_Read(void) {
    while(!RCIF);
    return RCREG;
}

uint8_t UART_Available(void) {
    return RCIF;
}

void UART_Flush(void) {
    while(UART_Available()) {
        UART_Read();
    }
}

// ============================================================================
// R307 FUNCTIONS
// ============================================================================
uint16_t R307_CalculateChecksum(uint8_t* packet, uint8_t len) {
    uint16_t sum = 0;
    uint8_t i;
    for(i = 6; i < len - 2; i++) {
        sum += packet[i];
    }
    return sum;
}

void R307_SendPacket(uint8_t cmd, uint8_t* params, uint8_t param_len) {
    uint8_t packet[32];
    uint8_t idx = 0;
    uint8_t i;
    uint16_t pkg_len;
    uint16_t checksum;
    
    packet[idx++] = 0xEF;
    packet[idx++] = 0x01;
    packet[idx++] = 0xFF;
    packet[idx++] = 0xFF;
    packet[idx++] = 0xFF;
    packet[idx++] = 0xFF;
    packet[idx++] = 0x01;
    
    pkg_len = param_len + 3;
    packet[idx++] = (pkg_len >> 8) & 0xFF;
    packet[idx++] = pkg_len & 0xFF;
    packet[idx++] = cmd;
    
    for(i = 0; i < param_len; i++) {
        packet[idx++] = params[i];
    }
    
    checksum = R307_CalculateChecksum(packet, idx);
    packet[idx++] = (checksum >> 8) & 0xFF;
    packet[idx++] = checksum & 0xFF;
    
    for(i = 0; i < idx; i++) {
        UART_Write(packet[i]);
    }
}

uint8_t R307_ReceivePacket(uint8_t* response, uint16_t timeout) {
    uint16_t timer = 0;
    uint8_t idx = 0;
    uint8_t i;
    
    while(timer < timeout) {
        if(UART_Available()) {
            uint8_t byte = UART_Read();
            if(idx == 0 && byte == 0xEF) {
                response[idx++] = byte;
            } else if(idx == 1 && byte == 0x01) {
                response[idx++] = byte;
                break;
            } else {
                idx = 0;
            }
        }
        __delay_ms(1);
        timer++;
    }
    
    if(idx < 2) return 0;
    
    for(i = 0; i < 11; i++) {
        timer = 0;
        while(!UART_Available() && timer < 100) {
            __delay_ms(1);
            timer++;
        }
        if(timer >= 100) return 0;
        response[idx++] = UART_Read();
    }
    
    return idx;
}

uint8_t R307_GetImage(void) {
    uint8_t response[32];
    UART_Flush();
    R307_SendPacket(R307_GENIMAGE, NULL, 0);
    
    if(R307_ReceivePacket(response, 1000) > 0) {
        return response[9];
    }
    return 0xFF;
}

uint8_t R307_Image2Tz(uint8_t slot) {
    uint8_t params[1] = {slot};
    uint8_t response[32];
    R307_SendPacket(R307_IMAGE2TZ, params, 1);
    
    if(R307_ReceivePacket(response, 2000) > 0) {
        return response[9];
    }
    return 0xFF;
}

uint8_t R307_CreateModel(void) {
    uint8_t response[32];
    R307_SendPacket(R307_REGMODEL, NULL, 0);
    
    if(R307_ReceivePacket(response, 2000) > 0) {
        return response[9];
    }
    return 0xFF;
}

uint8_t R307_StoreModel(uint8_t slot, uint16_t id) {
    uint8_t params[3] = {slot, (id >> 8) & 0xFF, id & 0xFF};
    uint8_t response[32];
    R307_SendPacket(R307_STORE, params, 3);
    
    if(R307_ReceivePacket(response, 2000) > 0) {
        return response[9];
    }
    return 0xFF;
}

uint8_t R307_Search(uint8_t slot, uint16_t* id, uint16_t* score) {
    uint8_t params[5] = {slot, 0x00, 0x00, 0x00, 0xC8};
    uint8_t response[32];
    R307_SendPacket(R307_SEARCH, params, 5);
    
    if(R307_ReceivePacket(response, 2000) > 0) {
        if(response[9] == 0x00) {
            *id = (uint16_t)((response[10] << 8) | response[11]);
            *score = (uint16_t)((response[12] << 8) | response[13]);
        }
        return response[9];
    }
    return 0xFF;
}

uint8_t R307_DeleteModel(uint16_t id, uint16_t count) {
    uint8_t params[4] = {(id >> 8) & 0xFF, id & 0xFF, 
                         (count >> 8) & 0xFF, count & 0xFF};
    uint8_t response[32];
    R307_SendPacket(R307_DELETE, params, 4);
    
    if(R307_ReceivePacket(response, 2000) > 0) {
        return response[9];
    }
    return 0xFF;
}

uint8_t R307_GetTemplateCount(uint16_t* count) {
    uint8_t response[32];
    R307_SendPacket(R307_TEMPLATECOUNT, NULL, 0);
    
    if(R307_ReceivePacket(response, 2000) > 0) {
        if(response[9] == 0x00) {
            *count = (uint16_t)((response[10] << 8) | response[11]);
            return 0x00;
        }
        return response[9];
    }
    return 0xFF;
}

// ============================================================================
// SYSTEM FUNCTIONS
// ============================================================================
void Display_Idle(void) {
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("There's Always");
    LCD_SetCursor(1, 0);
    LCD_String("Big Fish In Pond");
}

void Display_Menu(void) {
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String(menu_items[menu_index]);
    LCD_SetCursor(1, 0);
    LCD_String("UP/DN SEL=CONF");
}

uint8_t Get_Password_Input(void) {
    uint8_t input[PASSWORD_LENGTH];
    uint8_t idx = 0;
    uint8_t i;
    
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Enter Password:");
    LCD_SetCursor(1, 0);
    
    while(idx < PASSWORD_LENGTH) {
        if(Button_Read_Pass1()) {
            input[idx] = 1;
            LCD_Char('*');
            BUZZER = 1;
            __delay_ms(30);
            BUZZER = 0;
            idx++;
        }
        else if(Button_Read_Pass2()) {
            input[idx] = 2;
            LCD_Char('*');
            BUZZER = 1;
            __delay_ms(30);
            BUZZER = 0;
            idx++;
        }
        else if(Button_Read_Pass3()) {
            input[idx] = 3;
            LCD_Char('*');
            BUZZER = 1;
            __delay_ms(30);
            BUZZER = 0;
            idx++;
        }
        else if(Button_Read_Pass4()) {
            input[idx] = 4;
            LCD_Char('*');
            BUZZER = 1;
            __delay_ms(30);
            BUZZER = 0;
            idx++;
        }
    }
    
    for(i = 0; i < PASSWORD_LENGTH; i++) {
        if(input[i] != current_password[i]) {
            return 0;
        }
    }
    return 1;
}

void Verify_Fingerprint(void) {
    uint8_t result;
    uint16_t id, score;
    
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Place Finger...");
    
    result = R307_GetImage();
    if(result != 0x00) {
        LCD_SetCursor(1, 0);
        LCD_String("No Finger!");
        Buzzer_Error();
        __delay_ms(2000);
        return;
    }
    
    result = R307_Image2Tz(1);
    if(result != 0x00) {
        LCD_SetCursor(1, 0);
        LCD_String("Process Failed!");
        Buzzer_Error();
        __delay_ms(2000);
        return;
    }
    
    result = R307_Search(1, &id, &score);
    
    if(result == 0x00) {
        LCD_SetCursor(1, 0);
        LCD_String("Match! ID:");
        LCD_Number(id);
        Buzzer_Success();
        __delay_ms(1000);
        Servo_Open();
    } else {
        LCD_SetCursor(1, 0);
        LCD_String("No Match!");
        Buzzer_Error();
        __delay_ms(2000);
    }
}

void Add_Fingerprint(void) {
    uint16_t count;
    uint16_t new_id;
    
    R307_GetTemplateCount(&count);
    new_id = count + 1;
    
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Place Finger...");
    
    while(R307_GetImage() != 0x00) {
        __delay_ms(100);
    }
    
    if(R307_Image2Tz(1) != 0x00) {
        LCD_SetCursor(1, 0);
        LCD_String("Error!");
        Buzzer_Error();
        __delay_ms(2000);
        return;
    }
    
    LCD_SetCursor(1, 0);
    LCD_String("Remove Finger");
    Buzzer_Beep(1);
    __delay_ms(2000);
    
    LCD_SetCursor(1, 0);
    LCD_String("Place Again...  ");
    
    while(R307_GetImage() != 0x00) {
        __delay_ms(100);
    }
    
    if(R307_Image2Tz(2) != 0x00) {
        LCD_SetCursor(1, 0);
        LCD_String("Error!         ");
        Buzzer_Error();
        __delay_ms(2000);
        return;
    }
    
    if(R307_CreateModel() != 0x00) {
        LCD_SetCursor(1, 0);
        LCD_String("Match Failed!  ");
        Buzzer_Error();
        __delay_ms(2000);
        return;
    }
    
    if(R307_StoreModel(1, new_id) == 0x00) {
        LCD_Clear();
        LCD_SetCursor(0, 0);
        LCD_String("Saved! ID:");
        LCD_Number(new_id);
        Buzzer_Success();
        fingerprint_count++;
        __delay_ms(2000);
    } else {
        LCD_SetCursor(1, 0);
        LCD_String("Store Failed!  ");
        Buzzer_Error();
        __delay_ms(2000);
    }
}

void Delete_Fingerprint(void) {
    uint16_t count;
    uint16_t id, score;
    
    if(R307_GetTemplateCount(&count) != 0x00 || count == 0) {
        LCD_Clear();
        LCD_SetCursor(0, 0);
        LCD_String("No Fingerprints!");
        Buzzer_Error();
        __delay_ms(2000);
        return;
    }
    
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Total:");
    LCD_Number(count);
    LCD_SetCursor(1, 0);
    LCD_String("Verify to Del");
    __delay_ms(2000);
    
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Place Finger...");
    
    if(R307_GetImage() != 0x00) {
        LCD_SetCursor(1, 0);
        LCD_String("No Finger!");
        Buzzer_Error();
        __delay_ms(2000);
        return;
    }
    
    if(R307_Image2Tz(1) != 0x00) {
        LCD_SetCursor(1, 0);
        LCD_String("Process Failed!");
        Buzzer_Error();
        __delay_ms(2000);
        return;
    }
    
    if(R307_Search(1, &id, &score) != 0x00) {
        LCD_SetCursor(1, 0);
        LCD_String("Not Found!");
        Buzzer_Error();
        __delay_ms(2000);
        return;
    }
    
    if(R307_DeleteModel(id, 1) == 0x00) {
        LCD_Clear();
        LCD_SetCursor(0, 0);
        LCD_String("Deleted ID:");
        LCD_Number(id);
        Buzzer_Success();
        fingerprint_count--;
        __delay_ms(2000);
    } else {
        LCD_SetCursor(1, 0);
        LCD_String("Delete Failed!");
        Buzzer_Error();
        __delay_ms(2000);
    }
}

void Password_Open(void) {
    if(Get_Password_Input()) {
        LCD_Clear();
        LCD_SetCursor(0, 0);
        LCD_String("Password OK!");
        Buzzer_Success();
        __delay_ms(1000);
        Servo_Open();
    } else {
        LCD_Clear();
        LCD_SetCursor(0, 0);
        LCD_String("Wrong Password!");
        Buzzer_Error();
        __delay_ms(2000);
    }
}

void Change_Password(void) {
    uint8_t idx = 0;
    
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Verify Current:");
    __delay_ms(1000);
    
    if(!Get_Password_Input()) {
        LCD_Clear();
        LCD_SetCursor(0, 0);
        LCD_String("Wrong Password!");
        Buzzer_Error();
        __delay_ms(2000);
        return;
    }
    
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Enter New Pass:");
    LCD_SetCursor(1, 0);
    
    while(idx < PASSWORD_LENGTH) {
        if(Button_Read_Pass1()) {
            current_password[idx] = 1;
            LCD_Char('*');
            BUZZER = 1;
            __delay_ms(30);
            BUZZER = 0;
            idx++;
        }
        else if(Button_Read_Pass2()) {
            current_password[idx] = 2;
            LCD_Char('*');
            BUZZER = 1;
            __delay_ms(30);
            BUZZER = 0;
            idx++;
        }
        else if(Button_Read_Pass3()) {
            current_password[idx] = 3;
            LCD_Char('*');
            BUZZER = 1;
            __delay_ms(30);
            BUZZER = 0;
            idx++;
        }
        else if(Button_Read_Pass4()) {
            current_password[idx] = 4;
            LCD_Char('*');
            BUZZER = 1;
            __delay_ms(30);
            BUZZER = 0;
            idx++;
        }
    }
    
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Password Saved!");
    Buzzer_Success();
    __delay_ms(2000);
}

// ============================================================================
// MAIN FUNCTION
// ============================================================================
void main(void) {
    uint16_t temp_count;
    
    // Port Configuration
    TRISA = 0x0F;
    TRISB = 0x4F;
    TRISC = 0x80;
    TRISD = 0x00;
    
    PORTA = 0x00;
    PORTB = 0x00;
    PORTC = 0x00;
    PORTD = 0x00;
    
    ADCON1 = 0x06;
    
    // Initialize Peripherals
    LCD_Init();
    UART_Init();
    Servo_Init();
    
    // Startup Display
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Fingerprint Sec");
    LCD_SetCursor(1, 0);
    LCD_String("System v2.0");
    Buzzer_Beep(2);
    __delay_ms(2000);
    
    // Quick Servo Test
    LCD_Clear();
    LCD_SetCursor(0, 0);
    LCD_String("Testing Servo..");
    Servo_Set_Angle(90);
    __delay_ms(800);
    Servo_Set_Angle(0);
    __delay_ms(500);
    
    // Get Fingerprint Count
    if(R307_GetTemplateCount(&temp_count) == 0x00) {
        fingerprint_count = (uint8_t)temp_count;
        LCD_Clear();
        LCD_SetCursor(0, 0);
        LCD_String("Fingerprints:");
        LCD_Number(fingerprint_count);
        __delay_ms(1500);
    }
    
    Display_Idle();
    
    // Main Loop
    while(1) {
        if(system_state == 0) {
            if(Button_Read_Menu()) {
                system_state = 1;
                menu_index = 0;
                Display_Menu();
                BUZZER = 1;
                __delay_ms(30);
                BUZZER = 0;
            }
            __delay_ms(50);
        }
        else if(system_state == 1) {
            if(Button_Read_Up()) {
                if(menu_index > 0) 
                    menu_index--;
                else 
                    menu_index = MENU_ITEMS - 1;
                Display_Menu();
                BUZZER = 1;
                __delay_ms(30);
                BUZZER = 0;
            }
            else if(Button_Read_Down()) {
                if(menu_index < MENU_ITEMS - 1) 
                    menu_index++;
                else 
                    menu_index = 0;
                Display_Menu();
                BUZZER = 1;
                __delay_ms(30);
                BUZZER = 0;
            }
            else if(Button_Read_Confirm()) {
                system_state = 2;
                BUZZER = 1;
                __delay_ms(30);
                BUZZER = 0;
                
                switch(menu_index) {
                    case 0: Verify_Fingerprint(); break;
                    case 1: Add_Fingerprint(); break;
                    case 2: Delete_Fingerprint(); break;
                    case 3: Password_Open(); break;
                    case 4: Change_Password(); break;
                }
                
                system_state = 0;
                Display_Idle();
            }
            else if(Button_Read_Menu()) {
                system_state = 0;
                Display_Idle();
                BUZZER = 1;
                __delay_ms(30);
                BUZZER = 0;
            }
            __delay_ms(50);
        }
    }
}
